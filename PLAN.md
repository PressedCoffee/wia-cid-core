# WIA/CID "Core Pulse" - Phase 1 Implementation Plan

## 1. Overview & Goal

**Goal:** Deliver a robust and well-documented prediction validation smart contract system (`PredictionValidation.sol`) for Phase 1 of the WIA/CID project ("Core Pulse"). This includes the contract, deployment scripts, a comprehensive test suite, ABI export awareness, and essential documentation.

**Target:** Sepolia Testnet

## 2. Confirmed Decisions Summary

Based on our discussion, the following key decisions guide this implementation:

- **Tooling:** **Hardhat** (v2.x recommended) with TypeScript/JavaScript.
- **Language:** Solidity `^0.8.19`.
- **Network:** Sepolia.
- **Project Structure:** Standard Hardhat layout (see below).
- **Expiry Logic:** Strict resolution **before** `expiryBlock`. Attempts to resolve after expiry will revert (`PredictionExpired` error).
- **Access Control:** Resolution is restricted to the original submitting agent (`msg.sender == prediction.agent`). No `Ownable` pattern needed for Phase 1.
- **`variablesHash`:** Stored as a `bytes32` commitment. Verification is out of scope for Phase 1.
- **`description` Field:** Included as `string` in the `Prediction` struct. Users advised to keep descriptions concise due to gas costs.
- **`agentPredictions` Mapping:** Omitted to save gas. Agent prediction tracking will be handled off-chain via event indexing.
- **Error Handling:** Use custom errors for clarity and gas efficiency. Consumers of `getPrediction` should check `prediction.agent != address(0)` to validate existence.
- **Documentation:**
  - `README.md`: Main project documentation.
  - `docs/ARCHITECTURE_NOTES.md`: Specific notes on future Bitcoin-native porting considerations.
  - `docs/WIA-CID_Project_Overview.md`: Existing overview document.

## 3. Project Setup & Structure

- Initialize Hardhat project: `npx hardhat`
- Install dependencies: `npm install --save-dev @nomicfoundation/hardhat-toolbox dotenv` (or yarn equivalent)
- Create the following structure:

```
wia-cid-core-pulse/
├── contracts/
│   └── PredictionValidation.sol
├── scripts/
│   └── deploy.js
├── test/
│   └── PredictionValidation.test.js
├── docs/
│   ├── WIA-CID_Project_Overview.md  (Existing)
│   └── ARCHITECTURE_NOTES.md      (New)
├── artifacts/                     (Generated by Hardhat)
├── cache/                         (Generated by Hardhat)
├── .env                           (For secrets - add to .gitignore)
├── .gitignore
├── hardhat.config.js            (Configure for Solidity 0.8.19 & Sepolia)
├── PLAN.md                        (This file)
└── README.md                      (New)

```

- Configure `hardhat.config.js` for Solidity `0.8.19` and Sepolia network (RPC URL, deployer private key via `.env`).
- Create `.env` file (and `.env.example`) for storing `SEPOLIA_RPC_URL` and `PRIVATE_KEY`.
- Add `.env` and other relevant files (`node_modules`, `coverage/`, etc.) to `.gitignore`.

## 4. `contracts/PredictionValidation.sol` Details

- **SPDX License & Pragma:**
  ```solidity
  // SPDX-License-Identifier: MIT
  pragma solidity ^0.8.19;
  ```
- **Imports:** None strictly required for Phase 1 core logic (unless utility libraries like SafeMath were needed, but ^0.8.0 handles overflow).
- **NatSpec Documentation:** Implement for all contracts, functions, events, errors, and state variables.
- **Enums:**
  ```solidity
  /// @notice Possible outcomes for a prediction
  enum PredictionOutcome {
      Pending,   // Default state upon submission
      Success,   // Prediction validated as correct
      Failure,   // Prediction validated as incorrect
      Undetermined // Outcome could not be determined (e.g., manually set before expiry)
  }
  ```
- **Structs:**
  ```solidity
  /// @notice Represents a submitted prediction
  struct Prediction {
      uint256 id;             // Unique identifier for the prediction
      address agent;          // Address of the submitting agent
      uint8 confidence;       // Agent's confidence level (1-100)
      bytes32 variablesHash;  // Hash commitment to prediction variables (not validated in P1)
      uint256 submissionBlock; // Block number of submission
      uint256 expiryBlock;    // Block number after which prediction can no longer be resolved
      string description;     // Textual description (keep concise)
      PredictionOutcome outcome; // Current outcome status (starts Pending)
      uint256 resolutionBlock; // Block number of resolution (0 if Pending)
  }
  ```
- **State Variables:**
  ```solidity
  uint256 private _nextPredictionId; // Counter for prediction IDs, starts at 1
  mapping(uint256 => Prediction) public predictions; // Mapping from ID to Prediction struct
  ```
- **Events:**

  ```solidity
  /// @notice Emitted when a new prediction is submitted
  event PredictionSubmitted(
      uint256 indexed predictionId,
      address indexed agent,
      uint8 confidence,
      bytes32 variablesHash,
      uint256 expiryBlock,
      string description
  );

  /// @notice Emitted when a prediction outcome is resolved by the agent before expiry
  event PredictionResolved(
      uint256 indexed predictionId,
      address indexed resolver, // Will always be the original agent in P1
      PredictionOutcome outcome,
      uint256 resolutionBlock
  );
  ```

- **Custom Errors:**
  ```solidity
  /// @param provided The confidence value provided by the user
  error InvalidConfidence(uint8 provided);
  /// @param predictionId The ID of the prediction that was not found
  error PredictionNotFound(uint256 predictionId);
  /// @param predictionId The ID of the prediction being accessed
  /// @param caller The address attempting the action
  /// @param expectedAgent The address authorized to perform the action
  error NotAgent(uint256 predictionId, address caller, address expectedAgent);
  /// @param predictionId The ID of the prediction that is already resolved
  error AlreadyResolved(uint256 predictionId);
  /// @param predictionId The ID of the prediction that has expired
  /// @param currentBlock The current block number
  /// @param expiryBlock The prediction's expiry block number
  error PredictionExpired(uint256 predictionId, uint256 currentBlock, uint256 expiryBlock);
  /// @param predictionId The ID of the prediction
  error CannotResolvePending(uint256 predictionId);
  /// @param provided The expiry block provided by the user
  /// @param current The current block number
  error InvalidExpiryBlock(uint256 provided, uint256 current);
  ```
- **Functions:**
  - `constructor()`:
    - Initialize `_nextPredictionId = 1;`
  - `submitPrediction(uint8 confidence, bytes32 variablesHash, uint256 expiryBlock, string calldata description) external returns (uint256 predictionId)`:
    - Validate `confidence >= 1 && confidence <= 100`. Revert with `InvalidConfidence` if not.
    - Validate `expiryBlock > block.number`. Revert with `InvalidExpiryBlock` if not.
    - Assign `predictionId = _nextPredictionId;`.
    - Create and store `Prediction` struct in `predictions[predictionId]`.
    - Emit `PredictionSubmitted`.
    - Increment `_nextPredictionId++;`.
    - Return `predictionId`.
  - `resolvePrediction(uint256 predictionId, PredictionOutcome outcome)`:
    - Retrieve `Prediction storage prediction = predictions[predictionId];`.
    - Check existence: `prediction.agent != address(0)`. Revert with `PredictionNotFound`.
    - Check authorization: `msg.sender == prediction.agent`. Revert with `NotAgent`.
    - Check not already resolved: `prediction.outcome == PredictionOutcome.Pending`. Revert with `AlreadyResolved`.
    - Check not expired: `block.number <= prediction.expiryBlock`. Revert with `PredictionExpired`.
    - Check target outcome is not Pending: `outcome != PredictionOutcome.Pending`. Revert with `CannotResolvePending`.
    - Update `prediction.outcome = outcome;`.
    - Update `prediction.resolutionBlock = block.number;`.
    - Emit `PredictionResolved`.
  - `getPrediction(uint256 predictionId) external view returns (Prediction memory)`:
    - Return `predictions[predictionId]`. (Caller must check `agent != address(0)`).
- **Gas Optimizations:** Use custom errors, `calldata` for string input, avoid unnecessary state reads/writes (like the omitted `agentPredictions` map). Struct packing might offer minor benefits but prioritize clarity for Phase 1.
- **Diagrams:**

  - **Contract Structure:**

    ```mermaid
    graph TD
        A[PredictionValidation.sol] --> B(Enums: PredictionOutcome);
        A --> C(Structs: Prediction);
        A --> D(State Variables);
        D --> D1[nextPredictionId];
        D --> D2[predictions mapping];
        A --> E(Events);
        E --> E1[PredictionSubmitted];
        E --> E2[PredictionResolved];
        A --> F(Errors);
        F --> F1[InvalidConfidence];
        F --> F2[PredictionNotFound];
        F --> F3[NotAgent];
        F --> F4[AlreadyResolved];
        F --> F5[PredictionExpired];
        F --> F6[CannotResolvePending];
        F --> F7[InvalidExpiryBlock];
        A --> G(Functions);
        G --> G1[constructor];
        G --> G2[submitPrediction];
        G --> G3[resolvePrediction];
        G --> G4[getPrediction];
    ```

  - **Prediction Lifecycle (Phase 1 - Strict Expiry):**

    ```mermaid
    stateDiagram-v2
        [*] --> Pending: submitPrediction()
        Pending --> Success: resolvePrediction(Success)\n[caller == agent, block <= expiry, not resolved]
        Pending --> Failure: resolvePrediction(Failure)\n[caller == agent, block <= expiry, not resolved]
        Pending --> Undetermined: resolvePrediction(Undetermined)\n[caller == agent, block <= expiry, not resolved]

        %% Attempts to resolve after expiry (block > expiryBlock) will revert with PredictionExpired error.

        Success --> [*]
        Failure --> [*]
        Undetermined --> [*]
    ```

## 5. `scripts/deploy.js` Details

- Use `hre.ethers` from Hardhat Runtime Environment.
- Load deployer wallet securely using `process.env.PRIVATE_KEY` (via `dotenv`).
- Script logic:
  1.  Log network being deployed to.
  2.  Get deployer signer (`ethers.getSigners()`).
  3.  Get contract factory (`ethers.getContractFactory("PredictionValidation")`).
  4.  Deploy contract (`factory.deploy()`).
  5.  Wait for deployment confirmation (`contract.deployed()` or `contract.deployTransaction.wait()`).
  6.  Log deployed contract address (`contract.address`).
  7.  (Optional but recommended) Add steps for Etherscan verification using `hardhat-etherscan` plugin if configured.

## 6. `test/PredictionValidation.test.js` Details

- Use Hardhat testing utilities (Mocha, Chai, `ethers`, `hardhat-chai-matchers`).
- Employ `loadFixture` for efficient test setup.
- **Test Suite Structure:**
  - `describe("PredictionValidation", function () { ... });`
  - `describe("Deployment", function () { ... });` (Check initial state)
  - `describe("submitPrediction", function () { ... });`
  - `describe("resolvePrediction", function () { ... });`
  - `describe("getPrediction", function () { ... });`
  - `describe("Events", function () { ... });`
  - `describe("Access Control", function () { ... });`
- **Key Test Cases:**
  - **Deployment:** Correct initial `_nextPredictionId`.
  - **`submitPrediction`:**
    - Successful submission: Correct ID returned, struct stored correctly, event emitted with correct args.
    - Revert: Invalid confidence (0, 101).
    - Revert: Invalid `expiryBlock` (<= `block.number`).
    - Correct `_nextPredictionId` increment.
  - **`resolvePrediction`:**
    - Successful resolution (Success, Failure, Undetermined): Outcome/block updated, event emitted.
    - Revert: Non-existent `predictionId`.
    - Revert: Caller is not the agent.
    - Revert: Already resolved.
    - Revert: Attempting resolution after `expiryBlock`.
    - Revert: Attempting to resolve to `Pending`.
  - **`getPrediction`:** Retrieve valid prediction, handle non-existent ID (check for zeroed agent address).
  - **Events:** Test `PredictionSubmitted` and `PredictionResolved` emission with `emit(...)`.to.emit(...).withArgs(...)`.
  - **Access Control:** Explicitly test that non-agents cannot resolve.

## 7. `abi.json` Export

- The contract ABI will be available in `artifacts/contracts/PredictionValidation.sol/PredictionValidation.json` after compilation (`npx hardhat compile`). Note this location for client-side integration.

## 8. `README.md` Content Outline

- **Project Title:** WIA/CID - Core Pulse - Prediction Validation
- **Purpose:** Role in WIA system (tracking predictions/outcomes).
- **Contract Details:** Address (placeholder), Solidity Version, Network.
- **Functions:** Detailed descriptions (NatSpec style) of `submitPrediction`, `resolvePrediction`, `getPrediction`. Include parameters, returns, logic, access control, **strict expiry rule**, and events.
- **Events:** List and describe `PredictionSubmitted`, `PredictionResolved`.
- **Data Structures:** Describe `Prediction` struct, `PredictionOutcome` enum. Note `description` gas cost, `variablesHash` commitment role.
- **Deployment:** Prerequisites, setup (`.env`), compile, deploy command (`npx hardhat run scripts/deploy.js --network sepolia`).
- **Testing:** Command (`npx hardhat test`).
- **Usage Notes:** How to check `getPrediction` validity (`agent != address(0)`).
- **IPFS Audit Log Strategy:** Outline Phase 1 plan (off-chain listener -> format -> pin).
- **Phase 2 Compatibility:** Notes on CID simulation, Trust Mesh, planned extensions (mention documented-but-excluded fields).
- **Bitcoin-Native Porting:** Refer to `docs/ARCHITECTURE_NOTES.md`.

## 9. `docs/ARCHITECTURE_NOTES.md` Content Outline

- **Title:** Architectural Notes for Bitcoin-Native Porting
- **Context:** Goal of future RSK/Stacks compatibility.
- **Assumptions & Considerations:** Language (Solidity/Clarity), Account Model (EVM/UTXO), Fees, State, Tooling, Oracles.
- **Design Choices for Portability (Phase 1):** Minimal logic, separation of concerns, standard types, documented dependencies (`block.number`, `msg.sender`). Explicitly mention `variablesHash` current role vs. future validation potential.
- **Future Refactoring:** Areas needing changes for Bitcoin L2s.
